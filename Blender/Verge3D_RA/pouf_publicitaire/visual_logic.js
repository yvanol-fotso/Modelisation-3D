/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.7.1
 * Tue, 15 Apr 2025 08:36:59 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function getElement(id, isParent=false) {
        let elem;
        if (Array.isArray(id) && id[0] === 'CONTAINER') {
            if (appInstance !== null) {
                elem = appInstance.container;
            } else if (typeof _initGlob !== 'undefined') {
                // if we are on the initialization stage, we still can have access
                // to the container element
                const contId = _initGlob.container;
                elem = isParent ? parent.document.getElementById(contId)
                        : document.getElementById(contId);
            }
        } else if (Array.isArray(id) && id[0] === 'WINDOW') {
            elem = isParent ? parent : window;
        } else if (Array.isArray(id) && id[0] === 'DOCUMENT') {
            elem = isParent ? parent.document : document;
        } else if (Array.isArray(id) && id[0] === 'BODY') {
            elem = isParent ? parent.document.body : document.body;
        } else if (Array.isArray(id) && id[0] === 'QUERYSELECTOR') {
            elem = isParent ? parent.document.querySelector(id)
                    : document.querySelector(id);
        } else {
            elem = isParent ? parent.document.getElementById(id)
                    : document.getElementById(id);
        }
        return elem;
    }
        
    function getElements(ids, isParent=false) {
        const elems = [];
        if (Array.isArray(ids) && ids[0] !== 'CONTAINER' && ids[0] !== 'WINDOW'
                && ids[0] !== 'DOCUMENT' && ids[0] !== 'BODY'
                && ids[0] !== 'QUERYSELECTOR') {
            for (let i = 0; i < ids.length; i++) {
                elems.push(getElement(ids[i], isParent));
            }
        } else {
            elems.push(getElement(ids, isParent));
        }
        return elems;
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.type !== 'AmbientLight' && obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable && objName in _pGlob.objCache) {
            objFound = _pGlob.objCache[objName] || null;
        }
    
        if (objFound && objFound.name === objName) {
            return objFound;
        }
    
        if (appInstance.scene) {
            appInstance.scene.traverse(obj => {
                if (!objFound && isObjectWorthProcessing(obj) && (obj.name === objName)) {
                    objFound = obj;
                    if (pGlobAvailable) {
                        _pGlob.objCache[objName] = objFound;
                    }
                }
            });
        }
        return objFound;
    }
        
    const LIST_NONE = '<none>';
        
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    const transformEulerV3dToBlenderShortest = function() {
        const eulerTmp = new v3d.Euler();
        const eulerTmp2 = new v3d.Euler();
        const vec3Tmp = new v3d.Vector3();
    
        return function(euler, dest) {
            const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
            const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();
    
            const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
            const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();
    
            dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
            return transformCoordsSpace(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
        }
    }();
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    function RotationInterface() {
        /**
         * @ignore
         * For user manipulations use XYZ extrinsic rotations (which
         * are the same as ZYX intrinsic rotations)
         *     - Blender/Max/Maya use extrinsic rotations in the UI
         *     - XYZ is the default option, but could be set from
         *       some order hint if exported
         */
        this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
        this._actualRotation = new v3d.Euler();
    }
    
    Object.assign(RotationInterface, {
        initObject: function(obj) {
            if (obj.userData.puzzles === undefined) {
                obj.userData.puzzles = {}
            }
            if (obj.userData.puzzles.rotationInterface === undefined) {
                obj.userData.puzzles.rotationInterface = new RotationInterface();
            }
    
            const rotUI = obj.userData.puzzles.rotationInterface;
            rotUI.updateFromObject(obj);
            return rotUI;
        },
    });
    
    Object.assign(RotationInterface.prototype, {
        updateFromObject: function(obj) {
            const SYNC_ROT_EPS = 1e-8;
    
            if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                this._actualRotation.copy(obj.rotation);
                this._updateUserRotFromActualRot();
            }
        },
    
        getActualRotation: function(euler) {
            return euler.copy(this._actualRotation);
        },
    
        setUserRotation: function(euler) {
            // don't copy the order, since it's fixed to ZYX for now
            this._userRotation.set(euler.x, euler.y, euler.z);
            this._updateActualRotFromUserRot();
        },
    
        getUserRotation: function(euler) {
            return euler.copy(this._userRotation);
        },
    
        _updateUserRotFromActualRot: function() {
            const order = this._userRotation.order;
            this._userRotation.copy(this._actualRotation).reorder(order);
        },
    
        _updateActualRotFromUserRot: function() {
            const order = this._actualRotation.order;
            this._actualRotation.copy(this._userRotation).reorder(order);
        },
    });
        
    function getObjectName(obj) {
        // auto-generated from a multi-material object, use parent name instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.name;
        } else {
            return obj.name;
        }
    }
        
    function initObjectPicking(callback, eventType, mouseDownUseTouchStart=false,
            allowedMouseButtons=null) {
    
        const elem = appInstance.renderer.domElement;
        bindListener(elem, eventType, pickListener);
    
        if (eventType === 'mousedown') {
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, pickListener);
    
        } else if (eventType === 'dblclick') {
    
            let prevTapTime = 0;
    
            function doubleTapCallback(event) {
                const now = new Date().getTime();
                const timesince = now - prevTapTime;
    
                if (timesince < 600 && timesince > 0) {
                    pickListener(event);
                    prevTapTime = 0;
                    return;
                }
    
                prevTapTime = new Date().getTime();
            }
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, doubleTapCallback);
        }
    
        const raycaster = new v3d.Raycaster();
    
        function pickListener(event) {
    
            // to handle unload in loadScene puzzle
            if (!appInstance.getCamera()) {
                return;
            }
    
            event.preventDefault();
    
            let xNorm = 0;
            let yNorm = 0;
            if (event instanceof MouseEvent) {
                if (allowedMouseButtons !== null && allowedMouseButtons.indexOf(event.button) === -1) {
                    return;
                }
                xNorm = event.offsetX / elem.clientWidth;
                yNorm = event.offsetY / elem.clientHeight;
            } else if (event instanceof TouchEvent) {
                const rect = elem.getBoundingClientRect();
                xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
                yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
            }
    
            _pGlob.screenCoords.x = xNorm * 2 - 1;
            _pGlob.screenCoords.y = -yNorm * 2 + 1;
            raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
    
            const objList = [];
            appInstance.scene.traverse(obj => objList.push(obj));
    
            const intersects = raycaster.intersectObjects(objList, false);
            callback(intersects, event);
        }
    }
        
    function isObjectAmongObjects(objNameToCheck, objNames) {
        if (!objNameToCheck) {
            return false;
        }
    
        for (let i = 0; i < objNames.length; i++) {
            if (objNameToCheck === objNames[i]) {
                return true;
            } else {
                // also check children which are auto-generated for multi-material objects
                const obj = getObjectByName(objNames[i]);
                if (obj && obj.type === 'Group') {
                    for (let j = 0; j < obj.children.length; j++) {
                        if (objNameToCheck === obj.children[j].name) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
        
    function getMaterialEditableTextures(matName, collectSameNameMats=false) {
        let mats = [];
        if (collectSameNameMats) {
            mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        } else {
            const firstMat = v3d.SceneUtils.getMaterialByName(appInstance, matName);
            if (firstMat !== null) {
                mats = [firstMat];
            }
        }
    
        const textures = mats.reduce((texArray, mat) => {
            let matTextures = [];
            switch (mat.type) {
                case 'MeshNodeMaterial':
                    matTextures = Object.values(mat.nodeTextures);
                    break;
    
                case 'MeshStandardMaterial':
                    matTextures = [
                        mat.map, mat.lightMap, mat.aoMap, mat.emissiveMap,
                        mat.bumpMap, mat.normalMap, mat.displacementMap,
                        mat.roughnessMap, mat.metalnessMap, mat.alphaMap, mat.envMap
                    ];
                    break;
    
                default:
                    console.error('getMaterialEditableTextures: Unknown material type '
                            + mat.type);
                    break;
            }
    
            Array.prototype.push.apply(texArray, matTextures);
            return texArray;
        }, []);
    
        return textures.filter(elem => {
            // check Texture type exactly
            return elem && (elem.constructor === v3d.Texture
                    || elem.constructor === v3d.CompressedTexture
                    || elem.constructor === v3d.DataTexture
                    || elem.constructor === v3d.CanvasTexture
                    || elem.constructor === v3d.VideoTexture);
        });
    }
        
    function replaceMaterialEditableTexture(mat, oldTex, newTex) {
        switch (mat.type) {
            case 'MeshNodeMaterial':
                for (const name in mat.nodeTextures) {
                    if (mat.nodeTextures[name] === oldTex) {
                        mat.nodeTextures[name] = newTex;
                    }
                }
                break;
    
            case 'MeshStandardMaterial':
                const texNames = ['map', 'lightMap', 'aoMap', 'emissiveMap',
                        'bumpMap', 'normalMap', 'displacementMap', 'roughnessMap',
                        'metalnessMap', 'alphaMap', 'envMap'];
    
                texNames.forEach(name => {
                    if (mat[name] === oldTex) {
                        mat[name] = newTex;
                    }
                });
                break;
    
            default:
                console.error('replaceMaterialEditableTexture: Unsupported material type '
                        + mat.type);
                break;
        }
    
        // inherit some save params
        newTex.encoding = oldTex.encoding;
        newTex.wrapS = oldTex.wrapS;
        newTex.wrapT = oldTex.wrapT;
    }
        
    function encodeUnicodeStrToBase64(str) {
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
            function toSolidBytes(match, p1) {
                return String.fromCharCode('0x' + p1);
            }
        ));
    }
        
    function convertObjToJsonDataUrl(obj, mime='application/json') {
        if (typeof obj !== 'string') {
            obj = JSON.stringify(obj);
        }
        return 'data:' + mime + ';base64,' + encodeUnicodeStrToBase64(obj);
    }

    return {
        getElements, getObjectByName, LIST_NONE, bindListener,
        retrieveObjectNames, transformCoordsSpace, transformEulerV3dToBlenderShortest, getSceneCoordSystem,
        RotationInterface, getObjectName, initObjectPicking, isObjectAmongObjects,
        getMaterialEditableTextures, replaceMaterialEditableTexture, convertObjToJsonDataUrl,
    };
};

var PL = {};
// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    // setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem) continue;

        if ((attr == 'href' || attr == 'src') && value instanceof Promise) {
            // resolve promise value for url-based attributes
            value.then(function(response) {
                elem[attr] = response;
            });
        } else {
            elem[attr] = value;
        }
    }
}

// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}



// initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = true;


// initPreloader puzzle
_initGlob.output.initOptions.useCustomPreloader = true;
_initGlob.output.initOptions.preloaderStartCb = function() {
    _initGlob.percentage = 0;
    (function() {})();
};
_initGlob.output.initOptions.preloaderProgressCb = function(percentage) {
    _initGlob.percentage = percentage;
    (function() {
  setHTMLElemAttribute('innerHTML', String(Math.round(_initGlob.percentage)) + '%', 'progress_bar', true);
})();
};
_initGlob.output.initOptions.preloaderEndCb = function() {
    _initGlob.percentage = 100;
    (function() {
  setHTMLElemStyle('display', 'none', 'page_chargement', true);
})();
};

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}

this.procedures["process_opened_file"] = process_opened_file;
this.procedures["get_glbBase64"] = get_glbBase64;
this.procedures["set_state_changed"] = set_state_changed;

var PROC = {
    "process_opened_file": process_opened_file,
    "get_glbBase64": get_glbBase64,
    "set_state_changed": set_state_changed,
};

var VARS = Object.defineProperties({}, {
    '_cam_pos': { get: function() { return _cam_pos; }, set: function(val) { _cam_pos = val; } },
    'mode': { get: function() { return mode; }, set: function(val) { mode = val; } },
});

var _cam_pos, mode;

// featureAvailable puzzle
function featureAvailable(feature) {

    var userAgent = window.navigator.userAgent;
    var platform = window.navigator.platform;

    switch (feature) {
    case 'MOBILE':
        return (/Android|webOS|BlackBerry/i.test(userAgent) || v3d.Detector.checkIOS());

    case 'ANDROID':
        return /Android/i.test(userAgent);
    case 'IOS':
        return v3d.Detector.checkIOS();
    case 'WINDOWS':
        return ['Win32', 'Win64', 'Windows', 'WinCE'].indexOf(platform) !== -1;
    case 'MACOS':
        return (['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'].indexOf(platform) !== -1 && !v3d.Detector.checkIOS());
    case 'CHROMEOS':
        return /(CrOS)/.test(userAgent);
    case 'LINUX':
        return /Linux/.test(platform);

    case 'CHROME':
        // Chromium based
        return (!!window.chrome && !/Edge/.test(navigator.userAgent));
    case 'FIREFOX':
        return /Firefox/.test(navigator.userAgent);
    case 'IE':
        return /Trident/.test(navigator.userAgent);
    case 'EDGE':
        return /Edge/.test(navigator.userAgent);
    case 'SAFARI':
        return (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent));

    case 'TOUCH':
        return v3d.Detector.isTouchDevice();
    case 'RETINA':
        return window.devicePixelRatio >= 2;
    case 'HDR':
        return appInstance.useHDR;
    case 'WEBAUDIO':
        return v3d.Detector.checkWebAudio();
    case 'WEBGL':
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl')
        return !!gl;
    case 'WEBGL2':
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl2')
        return !!gl;
    case 'WOOCOMMERCE':
        var woo_fun = window.parent.v3d_woo_get_product_info || window.parent.parent.v3d_woo_get_product_info;
        return !!woo_fun;
    case 'DO_NOT_TRACK':
        if (navigator.doNotTrack == '1' || window.doNotTrack == '1')
            return true;
        else
            return false;
    default:
        return false;
    }

}

function setScreenScale(factor) {

    // already have maximum pixel ratio in HiDPI mode
    if (!appInstance.useHiDPIRenderPass)
        appInstance.renderer.setPixelRatio(factor);

    if (appInstance.postprocessing)
        appInstance.postprocessing.composer.setPixelRatio(factor);

    // to update possible post-processing passes
    appInstance.onResize();
}

var actionDisabled = false;

// exportToUSDZ puzzle
function exportToUSDZ(objSelector) {
    let obj;

    if (objSelector === '' || objSelector === PzLib.LIST_NONE)
        obj = appInstance.scene;
    else
        obj = PzLib.getObjectByName(objSelector);

    if (!obj)
        return;

    // COMPAT: iOS < 14
    if (Blob.prototype.arrayBuffer == undefined)
        Blob.prototype.arrayBuffer = function() {
            return new Response(this).arrayBuffer()
        }

    const usdzExporter = new v3d.USDZExporter();

    return new Promise(function(resolve, reject) {

        usdzExporter.parse(obj).then(function(value) {

            const dataUrl = URL.createObjectURL(new Blob([value], { type: 'application/octet-stream' }));
            resolve(dataUrl);

        }, function(reason) {

            console.error('exportToUSDZ: export failed: ' + reason);
            reject(reason);

        });

    });

}

// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = PzLib.getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;

        PzLib.bindListener(elem, eventType, callback);
    }
}

// checkARMode puzzle
function checkARMode(availableCb, usdzCb, unAvailableCb) {
    v3d.Detector.checkWebXR('immersive-ar', availableCb, function() {
        let usdzSupported = false;

        // NOTE: WebView in iOS reports as unsupported, use whitelist
        if (v3d.Detector.checkIOS() && window.webkit && window.webkit.messageHandlers) {
            if (/CriOS|EdgiOS|FxiOS|GSA|DuckDuckGo/.test(navigator.userAgent))
                usdzSupported = true;
        } else {
            const a = document.createElement('a');
            if (a.relList.supports('ar'))
                usdzSupported = true;
        }

        if (usdzSupported)
            usdzCb();
        else
            unAvailableCb();
    });
}

// show and hide puzzles
function changeVis(objSelector, bool) {
    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = PzLib.getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
        obj.resolveMultiMaterial().forEach(function(objR) {
            objR.visible = bool;
        });
    }
}

// setObjTransform puzzle
function setObjTransform(objSelector, isWorldSpace, mode, vector, offset){
    var x = vector[0];
      var y = vector[1];
      var z = vector[2];

    var objNames = PzLib.retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    var coordSystem = PzLib.getSceneCoordSystem();

    PzLib.transformCoordsSpace(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    PzLib.transformCoordsSpace(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        if (isWorldSpace && obj.parent) {
            obj.matrixWorld.decomposeE(obj.position, obj.rotation, obj.scale);

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

            obj.matrixWorld.composeE(obj.position, obj.rotation, obj.scale);
            obj.matrix.multiplyMatrices(_pGlob.mat4Tmp.copy(obj.parent.matrixWorld).invert(), obj.matrixWorld);
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

        } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                    _pGlob.eulerTmp);
            PzLib.transformCoordsSpace(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = PzLib.RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {
            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}

// openFile puzzle
function openFile(callback) {

    _pGlob.openedFile = '';
    _pGlob.openedFileMeta = {};

    var input = document.createElement('input');
    input.type = 'file';
    input.style = 'display: none';
    // NOTE: fixes iOS event issue
    document.body.appendChild(input);

    function inputChangeCb(event) {
        var file = event.target.files[0];

        var reader = new FileReader();

        PzLib.bindListener(reader, 'load', function() {
            _pGlob.openedFile = reader.result;
            _pGlob.openedFileMeta.name = file.name;
            _pGlob.openedFileMeta.size = file.size;
            _pGlob.openedFileMeta.type = file.type;
            callback();
            document.body.removeChild(input);
        }, false);

        reader.readAsDataURL(file);
    }
    PzLib.bindListener(input, 'change', inputChangeCb);

    if (appInstance.controls) {
        appInstance.controls.forceMouseUp();
    }

    input.click();
}

// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    PzLib.initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = PzLib.getObjectName(obj);
            var objNames = PzLib.retrieveObjectNames(objSelector);

            if (PzLib.isObjectAmongObjects(objName, objNames)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}

// openedFile puzzle
function openedFile(what) {
    switch (what) {
    case 'DATA':
        return _pGlob.openedFile;
        break;
    case 'NAME':
        return _pGlob.openedFileMeta.name || '';
        break;
    case 'EXTENSION':
        return (_pGlob.openedFileMeta.name || '').split('.').pop().toLowerCase();
        break;
    case 'SIZE':
        return _pGlob.openedFileMeta.size || 0;
        break;
    case 'TYPE':
        return _pGlob.openedFileMeta.type || '';
        break;
    }
}

// replaceTexture puzzle
function replaceTexture(matName, texName, texUrlOrElem, doCb) {

    const textures = PzLib.getMaterialEditableTextures(matName, true).filter(function(elem) {
        return elem.name == texName;
    });

    if (!textures.length)
        return;

    const mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);

    if (texUrlOrElem instanceof Promise) {

        texUrlOrElem.then(function(response) {
           processImageUrl(response);
        }, function(error) {});

    } else if (typeof texUrlOrElem == 'string') {

        processImageUrl(texUrlOrElem);

    /**
     * NOTE: not checking for the PzLib.MediaHTML5 constructor, because otherwise this
     * puzzle would always provide the code that's not needed most of the time
     */
    } else if (texUrlOrElem instanceof Object && texUrlOrElem.source
            instanceof HTMLVideoElement) {

        processVideo(texUrlOrElem.source);

    } else if (texUrlOrElem instanceof HTMLCanvasElement) {

        processCanvas(texUrlOrElem);

    } else {

        return;

    }

    function processImageUrl(url) {

        const isHDR = (url.search(/\.hdr$/) > 0);
        const isComp = (url.search(/\.ktx2/) > 0);

        let isCompOld = false;
        let isVideoOld = false;
        textures.forEach(function(elem) {
            if (elem.isCompressedTexture)
                isCompOld = true;
            if (elem.isVideoTexture)
                isVideoOld = true;
        });

        let loader;

        if (!isHDR && !isComp && !isCompOld && !isVideoOld) {
            loader = new v3d.ImageLoader();
            loader.setCrossOrigin('Anonymous');
        } else if (isComp) {
            loader = appInstance.loader.ktx2Loader;
            loader.setCrossOrigin('Anonymous');
        } else if (isCompOld || isVideoOld) {
            loader = new v3d.TextureLoader();
            loader.setCrossOrigin('Anonymous');
        } else {
            loader = new v3d.FileLoader();
            loader.setResponseType('arraybuffer');
        }

        loader.load(url, function(loadedData) {

            textures.forEach(function(elem) {

                elem.dispose();

                if (!isHDR && !isComp && !isCompOld && !isVideoOld) {

                    elem.image = loadedData;

                } else if (isComp || isCompOld || isVideoOld) {

                    mats.forEach(function(mat) {
                        loadedData.flipY = false;
                        loadedData.name = texName;
                        PzLib.replaceMaterialEditableTexture(mat, elem, loadedData);
                        mat.needsUpdate = true;
                    });

                } else {

                    // parse loaded HDR buffer
                    var rgbeLoader = new v3d.RGBELoader();
                    var texData = rgbeLoader.parse(loadedData);

                    elem.image = {
                        data: texData.data,
                        width: texData.width,
                        height: texData.height
                    }

                    elem.magFilter = v3d.LinearFilter;
                    elem.minFilter = v3d.LinearFilter;
                    elem.generateMipmaps = false;
                    elem.isDataTexture = true;
                }

                // update world material if it is using this texture
                if (appInstance.scene !== null && appInstance.scene.worldMaterial !== null) {
                    var wMat = appInstance.scene.worldMaterial;
                    for (let texName in wMat.nodeTextures) {
                        if (wMat.nodeTextures[texName] == elem) {
                            appInstance.updateEnvironment(wMat);
                        }
                    }
                }
            });

            // exec once
            doCb();

        });
    }

    function processVideo(elem) {
        const videoTex = new v3d.VideoTexture(elem);
        videoTex.flipY = false;
        videoTex.name = texName;

        let videoAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            textures.forEach(function(tex) {
                PzLib.replaceMaterialEditableTexture(mat, tex, videoTex);
            });

            mat.needsUpdate = true;
            // HACK: to assign new encoding in nodes, workaround for https://crbug.com/1256340
            // HACK: preserve links to uniform arrays which got replaced in updateNodeGraph()
            if (mat.isMeshNodeMaterial) {
                const nodeRGBArrSave = mat.nodeRGBArr;
                const nodeValueSave = mat.nodeValue;
                mat.updateNodeGraph();
                mat.nodeRGBArr = nodeRGBArrSave;
                mat.nodeValue = nodeValueSave;
            }

            videoAssigned = true;
        });

        if (videoAssigned) {
            if (elem.readyState < 1) {
                PzLib.bindListener(elem, 'loadedmetadata', doCb);
            } else {
                doCb();
            }
        }

    }

    function processCanvas(elem) {
        const canvasTex = new v3d.CanvasTexture(elem);
        canvasTex.flipY = false;
        canvasTex.name = texName;

        let canvasAssigned = false;

        var mats = v3d.SceneUtils.getMaterialsByName(appInstance, matName);
        mats.forEach(function(mat) {

            textures.forEach(function(tex) {
                PzLib.replaceMaterialEditableTexture(mat, tex, canvasTex);
            });

            mat.needsUpdate = true;
            canvasAssigned = true;
        });

        if (canvasAssigned) {

            if (PL) {
                PL.canvasTextures = PL.canvasTextures || {};
                PL.canvasTextures[canvasTex.image.id] = canvasTex;
            }

            doCb();
        }

    }
}

// Describe this function...
function process_opened_file() {
  replaceTexture('tissu_faces', 'import_image.jpg.001', openedFile('DATA'), function() {});
}

// exportToGLTF puzzle
function exportToGLTF(objSelector, onlyVisible, exportAnims, binary) {

    if (objSelector === '' || objSelector === PzLib.LIST_NONE) {

        var objs = [appInstance.scene];

    } else {

        var objs = PzLib.retrieveObjectNames(objSelector).map(function(objName) {
            return PzLib.getObjectByName(objName);
        });

    }

    if (objs.length) {

        var gltfExporter = new v3d.GLTFExporter();

        var clips = [];

        if (exportAnims) {
            for (var i = 0; i < appInstance.actions.length; i++) {
                var clip = appInstance.actions[i].getClip();
                if (clips.indexOf(clip) == -1)
                    clips.push(clip);
            }
        }

        var options = {
            onlyVisible: onlyVisible,
            binary: binary,
            trs: true,
            animations: clips
        }

        return new Promise(function(resolve, reject) {

            gltfExporter.parse(objs, function(result) {

                var dataUrl;

                if (result instanceof ArrayBuffer) {

                    dataUrl = URL.createObjectURL(new Blob([result], { type: 'application/octet-stream' }));

                } else {

                    dataUrl = PzLib.convertObjToJsonDataUrl(result, 'model/gltf+json');

                }

                resolve(dataUrl);

            }, function(error) {

                reject(error);

            }, options);

        });

    };

}

// Describe this function...
function get_glbBase64() {
  return exportToGLTF('export_objet', true, false, false);
}

// Describe this function...
function set_state_changed() {

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('if (!window.ar_cyber_module) return' + '\n' +
  '' + '\n' +
  'window.ar_cyber_module.set_isChanged(true)')))(appInstance, v3d, PL, VARS, PROC);

}


if (featureAvailable('RETINA')) {
  setScreenScale(window.devicePixelRatio);
}
if (featureAvailable('RETINA')) {
  setScreenScale(1.5);
}

if (featureAvailable('IOS')) {
  // Check AR capabilities
  checkARMode(function() {}, function() {
    eventHTMLElem('click', 'start_ar', true, function(event) {
      const elem = document.createElement('a'); elem.innerHTML = '<img>';
      if (elem && !actionDisabled) {
        actionDisabled=!0;function b(c,d){const e=a();return b=function(f,g){f=f-0x0;let h=e[f];return h;},b(c,d);}const n=b,exportedObject=app.scene.getObjectByName('export_objet');if(!exportedObject)return;app[n(0x0)][n(0x1)](),app[n(0x2)]=![];const options='allowsContentScaling=0';elem[n(0x3)]='ar',elem[n(0x4)]=n(0x5),document[n(0x6)](n(0x7))[n(0x8)][n(0x9)]=n(0xa);const geometrySaved={},objects=new v3d[(n(0xb))]();function a(){const r=['clock','stop','enableRender','rel','download','ar.usdz','getElementById','v3d-container','style','filter','blur(3px)','Group','name','usdzObjects','length','count','getX','getY','getZ','setXYZ','traverseVisible','isMesh','morphTargetInfluences','geometry','clone','applyMatrix4','matrix','morphAttributes','Mesh','material','attributes','normal','position','add','scene','then','remove','objCache','start','href','click','revokeObjectURL','removeAttribute','none'];a=function(){return r;};return a();}objects[n(0xc)]=n(0xd);function am(c,d,e){const o=b;for(let f=0x0;f<d[o(0xe)];f++){if(e[f]==0x0)continue;for(let g=0x0;g<c[o(0xf)];g++){const h=c[o(0x10)](g)+d[f][o(0x10)](g)*e[f],k=c[o(0x11)](g)+d[f][o(0x11)](g)*e[f],l=c[o(0x12)](g)+d[f][o(0x12)](g)*e[f];c[o(0x13)](g,h,k,l);}}}exportedObject[n(0x14)](function(c){const p=b;if(c[p(0x15)]){if(c[p(0x16)]){let d=0x0;for(let m=0x0;m<c[p(0x16)][p(0xe)];m++)d+=c[p(0x16)][m];if(!d)return;const e=c[p(0x17)][p(0x18)]();e[p(0x19)](c[p(0x1a)]),e[p(0x1b)]={};const f=new v3d[(p(0x1c))](e,c[p(0x1d)]),g=f[p(0x17)][p(0x1e)][p(0x1f)],h=f[p(0x17)][p(0x1e)][p(0x20)],j=c[p(0x17)][p(0x1b)][p(0x1f)],k=c[p(0x17)][p(0x1b)][p(0x20)],l=c[p(0x16)];am(g,j,l),am(h,k,l),objects[p(0x21)](f);}else objects[p(0x21)](c[p(0x18)]());}}),app[n(0x22)][n(0x21)](objects),exportToUSDZ(objects[n(0xc)])[n(0x23)](function(c){const q=b;app[q(0x22)][q(0x24)](objects);for(const d in _pGlob[q(0x25)])delete _pGlob[q(0x25)][d];onceReadyDo(),app[q(0x0)][q(0x26)](),app[q(0x2)]=!![];if(options[q(0xe)])c=c+'#'+options;elem[q(0x27)]=c,elem[q(0x28)](),URL[q(0x29)](elem[q(0x27)]),elem[q(0x2a)](q(0x27)),document[q(0x6)](q(0x7))[q(0x8)][q(0x9)]=q(0x2b),actionDisabled=!1,elem.remove()});
      }
      function onceReadyDo(){}
    });
  }, function() {});
} else if (featureAvailable('ANDROID')) {
  eventHTMLElem('click', 'start_ar', true, function(event) {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('if (!window.ar_cyber_module) return;' + '\n' +
    '' + '\n' +
    'const url = window.ar_cyber_module.ARmodelURL_cyber;' + '\n' +
    'if (!url) return;' + '\n' +
    '' + '\n' +
    'const btn = document.createElement("a");' + '\n' +
    'btn.href =' + '\n' +
    '  "intent://arvr.google.com/scene-viewer/1.0?file=" +' + '\n' +
    '  url +' + '\n' +
    '  "#Intent;scheme=https;package=com.google.android.googlequicksearchbox;action=android.intent.action.VIEW;S.browser_fallback_url=https://play.google.com/store/apps/details?id=com.google.ar.core;end;";' + '\n' +
    'btn.innerText = "Enter AR";' + '\n' +
    'btn.rel = "ar";' + '\n' +
    'btn.target = "_blank";' + '\n' +
    '' + '\n' +
    'btn.click();' + '\n' +
    'setTimeout(() => btn.remove(), 1500);')))(appInstance, v3d, PL, VARS, PROC);

  });
  eventHTMLElem('click', 'confirm_ar', true, function(event) {

    Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('if (!window.ar_cyber_module) return;' + '\n' +
    '' + '\n' +
    'window.ar_cyber_module.openAr({' + '\n' +
    '    onUploaded: (url) => {' + '\n' +
    '        const popup = window.ar_cyber_module.document_state.querySelector(\'.confirm_ar\');' + '\n' +
    '        if (popup) popup.style.display = \'flex\';' + '\n' +
    '    },' + '\n' +
    '    get_glbBase64: () => PROC[\'get_glbBase64\']' + '\n' +
    '})')))(appInstance, v3d, PL, VARS, PROC);

  });
}

eventHTMLElem('click', 'socle-1', true, function(event) {
  changeVis('Cube', true);
  changeVis(['Cylinder', null, null], false);
  set_state_changed();
});
eventHTMLElem('click', 'socle-2', true, function(event) {
  changeVis('Cylinder', true);
  changeVis(['Cube', null, null], false);
  set_state_changed();
});

eventHTMLElem('click', 'very_small', true, function(event) {
  setObjTransform(['Cube', 'Cylinder', null, null], false, 'scale', [1, 1, 1], false);
  set_state_changed();
});
eventHTMLElem('click', 'small', true, function(event) {
  setObjTransform(['Cube', 'Cylinder', null, null], false, 'scale', [1.11, 1.11, 1.11], false);
  set_state_changed();
});
eventHTMLElem('click', 'medium', true, function(event) {
  setObjTransform(['Cube', 'Cylinder', null, null], false, 'scale', [1.22, 1.22, 1.22], false);
  set_state_changed();
});

registerOnClick(['Cube', 'Cylinder', null, null], false, false, [0,1,2], function() {
  openFile(function() {
    process_opened_file();
  });
  set_state_changed();
}, function() {});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
